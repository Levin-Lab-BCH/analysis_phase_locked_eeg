function [] = characterize_PL_outputs(grp_proc_info_in)

%Old Version of code called "summarize_max_slopes_from_all_iterations
%Loads in the data and batch file generated by "generate_PL_non_PL_ITPC.m"
%script and does the following:

%1. Creates visualizes for each participants of their phase locked eeg
%response heat maps by condition
%2. Compute the slopes of the phase locked EEG response across selected
%conditions for every time/frequency pair
%3. Generate a table that stores the maximum slope in the early and late
%windows in the beta range
%4. If selected, plots the input/output curves of the phase locked response at the point of max slope for individual/group level 

close all
% Parse inputs
grp_colors = grp_proc_info_in.pl_grp_colors;
twin_to_highlight = grp_proc_info_in.pl_erp_win_to_highlight;
group = grp_proc_info_in.group_sub_dirs;
trials = grp_proc_info_in.pl_trial_subset_toplot;
freq_window = grp_proc_info_in.freq_band_lims; 
time_window = grp_proc_info_in.early_late_windows;
% Get input/output Dirs
figs = fullfile(grp_proc_info_in.src_dir{1,1},'figures','Phase_Locked_Power');
batch_file_dir = fullfile(grp_proc_info_in.src_dir{1,1},'Phase_Locked_Power');
save_name = strcat('PhaseLocking',grp_proc_info_in.pl_run_tag_toplot,'_',num2str(trials),'t_',num2str(grp_proc_info_in.pl_iterations_toplot),'i.mat'); % saves the phase locking mat by beapp run tag, number of trials subsampled and number of bootstrapping iterations

% Get channels and adjust based on channels that have actually been
% completed for dataset

% Load batch file
load(fullfile(batch_file_dir,save_name))
channels = intersect(grp_proc_info_in.pl_chans_to_plot,cellfun(@(x) str2num(x),batch_info.collapsed_metrics_computed.Properties.VariableNames));

close all
% Initialize fields to iterate over
orig_fields = {'phase_locked_collapsed','ersp_nonPL_collapsed'}; %corresponding fields to pull data from at indexes in the max slope tables
slope_fields = {'ersp_PL_slope','ersp_nonPL_slope'}; % field labels for computing slope
max_slope_fields = {'ersp_PL_max_slope_table','ersp_nonPL_max_slope_table'}; % field labels for generating the table that stores the max slope values at early/late frequency indices

% Check which conditions to plot, determine which positions these
% conditions belong to by cross referencing with batch_info.cond_values
% (ex: do you only want to plot hte 1st and 3rd condition vs 1st, 2nd, and 3rd)
conditions_to_estimate = grp_proc_info_in.conditions_to_estimate;
[~,~,conditions_to_plot] = intersect(conditions_to_estimate , batch_info.cond_values);
conditions_to_plot = conditions_to_plot';

% initialize other arrays
n_part_ceil = size(batch_info.collapsed_metrics_computed,1);
y_axis_all = nan(n_part_ceil,length(conditions_to_estimate),length(channels),length(group));
std_err_all = nan(n_part_ceil,length(conditions_to_estimate),length(channels),length(group));
output_all = nan(n_part_ceil,length(conditions_to_estimate),length(channels),length(group));
plot_log = 1;
for ng = 1:length(group)
    grp = group{ng};
    if ~isfield(data,grp) %if no participants from this group where completed, skip
        continue
    end
    g_fields = fields(data.(grp).ersp_nonPL_collapsed); %get the participant names for this diagnostic group
    n_part = length(g_fields);
    part_count(ng) = n_part;
    %initialize empty tables for condition range
    for i_field = 1:length(max_slope_fields)
        data.(grp).([max_slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]) = array2table(zeros(0,11),...
            'VariableNames',{'Channel','Max Slope_Early', 'Freq_Ind_Early',        'Freq (Hz) Early',         'Time_Ind Early','Time (ms) Early', ...
            'Max Slope_Late', 'Freq_Ind_Late',        'Freq (Hz) Late',         'Time_Ind Late','Time (ms) Late'});
    end

    for file = 1:n_part
        if file < n_part + 1
            n = g_fields{file};
            field_iterator = 1;
            if size(data.(grp).ersp_nonPL_collapsed.(n),2)<max(conditions_to_plot)
                continue
            end
        else
            n = 'ggrpav';
            field_iterator = 3:4;
        end

        subplot_iterator = [1 2 1 2];
        chan_iterator = 0;
        for i_chan = channels
            chan_iterator = chan_iterator + 1;
            if plot_log
                f1=  figure('Position',[488,72.2,736.2,689],'Name',[grp,' ',n(2:5),' Slopes ',num2str(conditions_to_estimate),' channels:',num2str(i_chan),'trial_thresh: ',num2str(trials)]);
            end
            clear curr_field_data
            for i_field = field_iterator
                % Get data for the current field and channel
                curr_field_data = data.(grp).(orig_fields{i_field}).(n)(i_chan,conditions_to_plot);
              
                % Compute slope matrix
                tic
                data.(grp).([slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]).(n){i_chan,1} = get_tf_slopes(conditions_to_estimate,curr_field_data);
                toc
                % Extract max slope info from slope matrix
                data.(grp).([max_slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]) = [data.(grp).([max_slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]); get_max_slope_table(data.(grp).([slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]).(n){i_chan,1},data.(grp).ITCtimes,data.(grp).freqs,n,i_chan,freq_window,time_window)];

                %Plot slope for this fields by individaul
                field = [max_slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')];
                curr_tab = data.(grp).(field)([n(1:5),'_E',num2str(i_chan)],:);

                % Compute slope fits/get info for input/output curves
                y_axis = cellfun(@(x) x(curr_tab.("Freq_Ind_Early"),curr_tab.("Time_Ind Early")), curr_field_data);
                y_axis_all(file,:,chan_iterator,ng) = y_axis;
                std_err_all(file,:,chan_iterator,ng) = cellfun(@(x) x(curr_tab.("Freq_Ind_Early"),curr_tab.("Time_Ind Early")), data.(grp).([orig_fields{i_field},'_std_error']).(n)(i_chan,conditions_to_plot));

                [output] =polyfit(conditions_to_estimate(1:end),y_axis(1:end),1);

                xFit = linspace(min(conditions_to_estimate),max(conditions_to_estimate),length(conditions_to_estimate));
                output_all(file,:,chan_iterator,ng) = output(1);
                yFit_all(file,:,chan_iterator,ng) = polyval(output,xFit);
       
                %Plot if desired 
                if plot_log
                    %Plot slope for this fields by individaul
                    f1;
                    subplot(length(field_iterator), 1, subplot_iterator(i_field), 'Parent', f1);
                    plot_subplot([n(2:5),'Slope of Phase Locked EEG '],data,data.(grp).ITCtimes,data.(grp).([slope_fields{i_field} strrep(num2str(conditions_to_estimate),' ','_')]).(n){i_chan,1},grp,[0 .015],twin_to_highlight,[],freq_window,time_window); hold on
                    
                    %Plot phase locked or non-phase locked power by condition for this
                    %individual
                    fX=  figure('Position',[400,72.2,1100,689],'Name',[grp,' ',n(2:5),orig_fields{i_field},num2str(conditions_to_estimate),' channels:',num2str(i_chan),'trial_thresh: ',num2str(trials)]);
                    for ii = 1:length(conditions_to_estimate)
                        P = curr_field_data{1,ii};
                        subplot(1,length(conditions_to_estimate),ii);
                        plot_subplot([num2str(conditions_to_estimate(ii)) 'mN'],data,data.(grp).ITCtimes,P,grp,[0 .8],twin_to_highlight,[],freq_window,time_window);
                    end
                end
            end
            if plot_log %Save the Slope HeatMaps and the Phase Locked Heatmaps
                if ~isdir(fullfile(figs,num2str(i_chan),'Slope_HeatMaps')); mkdir (fullfile(figs,num2str(i_chan),'Slope_HeatMaps')); end
                saveas(f1,fullfile(figs,[num2str(i_chan)],'Slope_HeatMaps',[grp ,' ',n(2:5),'_','Slopes','_Trials_',num2str(trials),'Conds', strrep(num2str(conditions_to_estimate),' ','_')]),'jpg')
                saveas(f1,fullfile(figs,[num2str(i_chan)],'Slope_HeatMaps',[grp ' ' n(2:5),'_','Slopes','_Trials_',num2str(trials),'Conds',num2str(conditions_to_estimate)]))
                 if ~isdir(fullfile(figs,num2str(i_chan),'Condition_HeatMaps')); mkdir (fullfile(figs,num2str(i_chan),'Condition_HeatMaps')); end
                 saveas(fX,fullfile(figs,[num2str(i_chan)],'Condition_HeatMaps',[grp ,' ',n(2:5),' ','PL',' Trials ',num2str(trials),'Conds', num2str(conditions_to_estimate)]),'jpg')
                 saveas(fX,fullfile(figs,[num2str(i_chan)],'Condition_HeatMaps',[grp ' ' n(2:5),' ','PL',' Trials ',num2str(trials),'Conds',num2str(conditions_to_estimate)]))
                close (f1); close(fX)
            end
        end
    end
end

%% Plot Input Output Curves
for chan_iterator = 1:length(channels)
    f2 = figure('Name',['I/O',num2str(channels(chan_iterator)),num2str(conditions_to_estimate)]);
    for ng = 1:length(group)
     
        if ~isfield(data,grp) %if no participants from this group where completed, skip
            continue
        end
        file_std = nanstd(y_axis_all(:,:,chan_iterator,ng)) ;
        file_length = sum(~isnan(y_axis_all(:,1,chan_iterator,ng)));
        std_error = file_std./sqrt(file_length);
        % Plot individual lines jittering them slightly to improve
        % vizualization
        if grp_proc_info_in.plot_indi_in_out
            for i_p = 1:size(y_axis_all,1)
                errorbar(conditions_to_estimate + rand(size(conditions_to_estimate))*.5,y_axis_all(i_p,:,chan_iterator,ng),[std_err_all(i_p,:,chan_iterator,ng)],'Color',grp_colors{ng},'LineWidth',.5,'Marker','*','HandleVisibility','off');
                hold on
            end
        end

        % Plot individual fit lines
        if grp_proc_info_in.plot_indi_lines_of_fit
            plot(xFit,yFit_all(:,:,chan_iterator,ng),'Color',[.7 .7 .7],'LineWidth',.5,'HandleVisibility','off'); hold on;
        end

        % Plot group average with group std error
        if grp_proc_info_in.plot_grp_av
            errorbar(conditions_to_estimate, nanmean(y_axis_all(:,:,chan_iterator,ng),1),[std_error],'-o','LineWidth',2,'Color',grp_colors{ng},'DisplayName',[group{ng},' n=',num2str(file_length)])
            hold on;
            legend('Location','Best');
        end
    end
    xlabel('Intensity (mN)')
    ylabel('Phase-Locked EEG Response')
    xticks(conditions_to_estimate)
    xlim([min(conditions_to_estimate), max(conditions_to_estimate)+1])
    title(['Phase-Locked EEG Input/Output Curve Channel ',num2str(channels(chan_iterator))])
    if ~isdir(fullfile(figs,num2str(i_chan),'Condition_HeatMaps')); mkdir (fullfile(figs,num2str(i_chan),'Condition_HeatMaps')); end
    saveas(f2,fullfile(figs,num2str(channels(chan_iterator)),[num2str(conditions_to_estimate),'IOs',' ','Slopes',' Trials ',num2str(trials)]),'jpg')
    saveas(f2,fullfile(figs,num2str(channels(chan_iterator)),[num2str(conditions_to_estimate),'IOs',' ','Slopes',' Trials ',num2str(trials)]))
    % close (f2)
end

% plot slope comparisons - haven't been using much for now
for chan_iterator = 1:length(channels)
    f2 = figure('Name',['Slope Scatter',num2str(channels(chan_iterator)),num2str(conditions_to_estimate)]);
    for ng = 1:length(group)
        if ~isfield(data,grp) %if no participants from this group where completed, skip
            continue
        end
        hold on

        scatter(ng, squeeze(output_all(:,1,chan_iterator,ng)),[],grp_colors{ng})
        hold on;
        %  legend('Location','Best');
    end
    title([num2str(conditions_to_estimate), 'Phase-Locked EEG Max Slope Scatter Channel ',num2str(channels(chan_iterator))])

    % saveas(f2,fullfile(figs,num2str(channels(chan_iterator)),[num2str(conditions_to_estimate),'Scatter',' ','Slopes',' Trials ',num2str(trials)]),'jpg')
    %saveas(f2,fullfile(figs,num2str(channels(chan_iterator)),[num2str(conditions_to_estimate),'Scatter',' ','Slopes',' Trials ',num2str(trials)]))
     close (f2)
end
%move to output directory
cd(figs)